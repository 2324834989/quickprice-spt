<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SPTarkov.Reflection</name>
    </assembly>
    <members>
        <member name="T:SPTarkov.Reflection.CodeWrapper.CodeGenerator">
            <summary>
            Helper class to generate IL code for transpilers
            </summary>
        </member>
        <member name="T:SPTarkov.Reflection.Patching.AbstractPatch">
            <summary>
                Harmony patch wrapper class. See mod example 6.1 for usage.
            </summary>
            <remarks>
                A known limitation is that exceptions and logging are only sent to the console and are not color coded. There is no disk logging here.
            </remarks>
        </member>
        <member name="P:SPTarkov.Reflection.Patching.AbstractPatch.TargetMethod">
            <summary>
                Method this patch targets
            </summary>
        </member>
        <member name="P:SPTarkov.Reflection.Patching.AbstractPatch.IsActive">
            <summary>
                Is this patch active?
            </summary>
        </member>
        <member name="P:SPTarkov.Reflection.Patching.AbstractPatch.IsManaged">
            <summary>
                Is this patch managed by the PatchManager?
            </summary>
        </member>
        <member name="P:SPTarkov.Reflection.Patching.AbstractPatch.HarmonyId">
            <summary>
                The harmony Id assigned to this patch, usually the name of the patch class.
            </summary>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.GetTargetMethod">
            <summary>
            Get original method
            </summary>
            <returns>Method</returns>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.GetPatchMethods(System.Type)">
            <summary>
            Get HarmonyMethod from string
            </summary>
            <param name="attributeType">Attribute type</param>
            <returns>Method</returns>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.Enable">
            <summary>
            Apply patch to target
            </summary>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.Enable(HarmonyLib.Harmony)">
            <summary>
                Internal use only, called from the patch manager.
            </summary>
            <param name="harmony">Harmony instance of the patch manager</param>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.Disable">
            <summary>
            Remove applied patch from target
            </summary>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.AbstractPatch.Disable(HarmonyLib.Harmony)">
            <summary>
                Internal use only, called from the patch manager.
            </summary>
            <param name="harmony">Harmony instance of the patch manager</param>
        </member>
        <member name="T:SPTarkov.Reflection.Patching.IgnoreAutoPatchAttribute">
            <summary>
                If added to a patch, it will not be used during auto patching
            </summary>
        </member>
        <member name="T:SPTarkov.Reflection.Patching.DebugPatchAttribute">
            <summary>
                If added to a patch, it will only be enabled during debug builds
            </summary>
        </member>
        <member name="T:SPTarkov.Reflection.Patching.ModPatchCache">
            <summary>
                Cache of active patches for mod developers to use for compatibility reasons
            </summary>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.ModPatchCache.GetActivePatches">
            <summary>
                Get all active patches
            </summary>
            <returns>
            List of active patches
            </returns>
            <remarks>
                This should never be called before PreSptLoad is completed, otherwise could be empty.
            </remarks>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.ModPatchCache.GetActivePatchedMethodNames">
            <summary>
                Get all actively patched target method names
            </summary>
            <returns>
            List of fully quantified method names; including namespace, type and method name
            </returns>
            <remarks>
                This should never be called before PreSptLoad is completed, otherwise could be empty.
            </remarks>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.ModPatchCache.AddPatch(SPTarkov.Reflection.Patching.AbstractPatch)">
            <summary>
                Add a patch to the cache
            </summary>
            <param name="patch">Patch to add to cache</param>
            <remarks>
                DO NOT PATCH THIS METHOD, IT IS INTERNAL FOR A REASON. YOU ARE ONLY HARMING OTHER MOD DEVELOPERS BY DOING SO.
            </remarks>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.ModPatchCache.RemovePatch(SPTarkov.Reflection.Patching.AbstractPatch)">
            <summary>
                Remove a patch from the cache
            </summary>
            <param name="patch">Patch to remove</param>
            <returns>
            True if patch was removed
            </returns>
            <remarks>
                DO NOT PATCH THIS METHOD, IT IS INTERNAL FOR A REASON. YOU ARE ONLY HARMING OTHER MOD DEVELOPERS BY DOING SO.
            </remarks>
        </member>
        <member name="T:SPTarkov.Reflection.Patching.PatchManager">
            <summary>
                A manager for your patches. You MUST set the PatcherName property BEFORE enabling patches. This is used to identify your harmony instance.
            </summary>
            <remarks>
                A known limitation is that exceptions and logging are only sent to the console and are not color coded. There is no disk logging here.
            </remarks>
        </member>
        <member name="P:SPTarkov.Reflection.Patching.PatchManager.PatcherName">
            <summary>
                Patcher name to be assigned to the harmony instance this manager controls. MUST be set prior to patching
            </summary>
        </member>
        <member name="P:SPTarkov.Reflection.Patching.PatchManager.AutoPatch">
            <summary>
                Should the manager find and enable patches on its own?
            </summary>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.AddPatch(SPTarkov.Reflection.Patching.AbstractPatch)">
            <summary>
                Adds a single patch
            </summary>
            <param name="patch">Patch to add</param>
            <exception cref="T:SPTarkov.Reflection.Patching.PatchException"> Thrown if autopatch is enabled. You cannot add patches during auto patching. </exception>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.AddPatches(System.Collections.Generic.List{SPTarkov.Reflection.Patching.AbstractPatch})">
            <summary>
                Adds a list of patches
            </summary>
            <param name="patchList">List of patches to add</param>
            <exception cref="T:SPTarkov.Reflection.Patching.PatchException"> Thrown if autopatch is enabled. You cannot add patches during auto patching. </exception>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.GetPatches(System.Reflection.Assembly)">
            <summary>
                Retrieves a list of types from the given assembly that inherit from <see cref="T:SPTarkov.Reflection.Patching.AbstractPatch"/>, <br/>
            excluding those marked with <see cref="T:SPTarkov.Reflection.Patching.IgnoreAutoPatchAttribute"/> and, in non-debug builds, <br/>
            excluding those marked with <see cref="T:SPTarkov.Reflection.Patching.DebugPatchAttribute"/>.
            </summary>
            <param name="assembly">The assembly to scan for patch types.</param>
            <returns>
            A list of types that inherit from <see cref="T:SPTarkov.Reflection.Patching.AbstractPatch"/> and meet the filtering criteria.
            </returns>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.EnablePatches">
            <summary>
                Enables all patches, if <see cref="P:SPTarkov.Reflection.Patching.PatchManager.AutoPatch"/> is enabled it will find them automatically
            </summary>
            <exception cref="T:SPTarkov.Reflection.Patching.PatchException">
                Thrown if PatcherName was not set, or there are no patches found during auto patching, or there are no patches added manually.
            </exception>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.DisablePatches">
            <summary>
                Disables all patches, if <see cref="P:SPTarkov.Reflection.Patching.PatchManager.AutoPatch"/> is enabled it will find them automatically
            </summary>
            <exception cref="T:SPTarkov.Reflection.Patching.PatchException">
                Thrown if there are no enabled patches, or no patches are found during auto patch disabling, or there were no patches added manually to disable.
            </exception>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.EnablePatch(SPTarkov.Reflection.Patching.AbstractPatch)">
            <summary>
                Enables a single patch
            </summary>
            <param name="patch"></param>
            <exception cref="T:SPTarkov.Reflection.Patching.PatchException">
                Thrown if PatcherName was not set
            </exception>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.DisablePatch(SPTarkov.Reflection.Patching.AbstractPatch)">
            <summary>
                Disables a single patch
            </summary>
            <param name="patch"></param>
        </member>
        <member name="M:SPTarkov.Reflection.Patching.PatchManager.IsAssemblyDebugBuild(System.Reflection.Assembly)">
            <summary>
                Check if an assembly is built in debug mode
            </summary>
            <param name="assembly">Assembly to check</param>
            <returns>True if debug mode</returns>
        </member>
    </members>
</doc>
