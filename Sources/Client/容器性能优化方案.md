# 大容量容器查询卡顿问题 - 性能优化方案

## 📊 问题分析

### 当前实现的性能瓶颈

在 `TestTooltipPatch.cs` 的 `CalculateContainerItemsPrice()` 方法中存在以下性能问题：

#### 1. **递归深度问题**
```csharp
// 行 1164-1329: CalculateContainerItemsPrice
private static double CalculateContainerItemsPrice(Item container, int depth)
{
    if (depth >= 50)  // 最大递归深度 50 层
        return 0;

    // 递归调用：
    // - 背包里的背包 → 递归
    // - 武器配件 → PriceCalculator.CalculateWeaponModsPrice() → 递归
    // - 弹匣子弹 → 遍历所有子弹
}
```

**问题**：
- 背包套娃（背包里有背包）导致递归层数增加
- 每层都要遍历所有物品
- 时间复杂度：O(n × m × d)，其中 n=物品数，m=平均配件数，d=递归深度

#### 2. **反射调用开销**
```csharp
// 每个物品都要进行大量反射调用
var gridsProperty = containerType.GetProperty("Grids");      // 反射
var itemsProperty = grid.GetType().GetProperty("Items");     // 反射
var price = PriceDataService.Instance.GetPrice(templateId); // 字典查询
```

**问题**：
- 反射比直接属性访问慢 10-100 倍
- 每个物品至少 2-3 次反射调用
- 大容器（100+ 物品）会有 200-300 次反射调用

#### 3. **武器和弹匣的深度计算**
```csharp
// 容器里的武器 → 计算所有配件
if (gridItem is Weapon weaponInContainer)
{
    double weaponModsPrice = PriceCalculator.CalculateWeaponModsPrice(weaponInContainer);
    total += weaponModsPrice;  // 递归计算所有配件！
}

// 容器里的弹匣 → 遍历所有子弹
else if (gridItem is MagazineItemClass magazineInContainer)
{
    foreach (var cartridge in magazineInContainer.Cartridges.Items)
    {
        // 查询每颗子弹的价格
    }
}
```

**问题**：
- 一个满配武器可能有 20+ 个配件
- 一个弹匣可能有 30-60 发子弹
- 如果容器里有 10 把武器、20 个弹匣，计算量爆炸式增长

#### 4. **实时计算没有缓存**
```csharp
// 每次鼠标悬停都重新计算
public static void Prefix(SimpleTooltip __instance, ref string text, ref float delay)
{
    // ...
    text += FormatContainerPriceText(item, slots);  // 每次都重新计算！
}
```

**问题**：
- 没有缓存机制
- 即使是同一个容器，每次悬停都重新计算
- 大容器每次都要花费 100-500ms

---

## 🚀 优化方案（按优先级排序）

### 方案 1: **限制计算深度 + 简化模式**（推荐⭐⭐⭐⭐⭐）

#### 实现方式
```csharp
// 在配置中添加选项
public static ConfigEntry<int> MaxContainerItemsToCalculate; // 最大计算物品数
public static ConfigEntry<bool> SimplifyContainerCalculation; // 简化容器计算

// 修改 CalculateContainerItemsPrice
private static double CalculateContainerItemsPrice(Item container, int depth)
{
    // 1. 降低最大递归深度：50层 → 5层
    if (depth >= 5)
        return 0;

    int itemCount = 0;
    int maxItems = Settings.MaxContainerItemsToCalculate.Value; // 默认 50

    foreach (var gridItem in itemsList)
    {
        if (itemCount >= maxItems)
        {
            // 超过限制，停止计算并显示提示
            Plugin.Log.LogWarning($"容器物品超过 {maxItems} 个，停止详细计算");
            break;
        }

        // 2. 简化模式：跳过配件和子弹的深度计算
        if (Settings.SimplifyContainerCalculation.Value)
        {
            // 只计算物品本身价格
            total += itemPrice.Value * gridItem.StackObjectsCount;
            itemCount++;
            continue;
        }

        // 3. 完整模式：保留原有逻辑
        // ...
    }
}
```

#### 效果
- **性能提升**：70-80%
- **用户体验**：几乎无感知延迟（<100ms）
- **准确性**：简化模式略有误差，但大幅提升性能

---

### 方案 2: **结果缓存机制**（推荐⭐⭐⭐⭐）

#### 实现方式
```csharp
// 添加静态缓存
private static Dictionary<string, (double price, DateTime timestamp)> _containerPriceCache
    = new Dictionary<string, (double, DateTime)>();

private static double CalculateContainerItemsPrice(Item container, int depth)
{
    // 检查缓存（5秒有效期）
    string cacheKey = container.Id;
    if (_containerPriceCache.TryGetValue(cacheKey, out var cached))
    {
        if ((DateTime.Now - cached.timestamp).TotalSeconds < 5)
        {
            return cached.price;  // 使用缓存结果
        }
    }

    // 计算价格
    double total = /* 原有计算逻辑 */;

    // 保存到缓存
    _containerPriceCache[cacheKey] = (total, DateTime.Now);

    return total;
}

// 定期清理缓存（防止内存泄漏）
private static void CleanupCache()
{
    var now = DateTime.Now;
    var keysToRemove = _containerPriceCache
        .Where(kvp => (now - kvp.Value.timestamp).TotalSeconds > 30)
        .Select(kvp => kvp.Key)
        .ToList();

    foreach (var key in keysToRemove)
        _containerPriceCache.Remove(key);
}
```

#### 效果
- **性能提升**：90-95%（重复查询时）
- **内存占用**：每个容器约 24 字节
- **适用场景**：频繁悬停同一个容器

---

### 方案 3: **渐进式加载 + 异步计算**（复杂度高⭐⭐⭐）

#### 实现方式
```csharp
// Tooltip 初始显示时只显示容器本身价格
private static string FormatContainerPriceText(Item container, int slots)
{
    var sb = new StringBuilder();
    sb.Append("\n");

    // 立即显示容器本身价格
    var containerPrice = PriceDataService.Instance.GetPrice(container.TemplateId);
    sb.Append($"\n跳蚤市场: {TextFormatting.FormatPrice(containerPrice.Value)}");
    sb.Append($"\n内部物品: 计算中...");

    // 异步计算内部物品价格
    _ = Task.Run(() => {
        double itemsPrice = CalculateContainerItemsPrice(container, 0);
        // 更新缓存，下次悬停时直接显示
        _containerPriceCache[container.Id] = (itemsPrice, DateTime.Now);
    });

    return sb.ToString();
}
```

#### 效果
- **首次显示**：立即（<10ms）
- **完整结果**：后台计算，下次悬停显示
- **复杂度**：需要处理多线程和缓存同步

---

### 方案 4: **智能跳过策略**（推荐⭐⭐⭐⭐⭐）

#### 实现方式
```csharp
private static string FormatContainerPriceText(Item container, int slots)
{
    // 预估容器大小
    int estimatedItemCount = EstimateContainerItemCount(container);

    if (estimatedItemCount > 100)
    {
        // 大容器：仅显示基础信息 + 警告
        sb.Append($"\n⚠️ 容器物品过多（约{estimatedItemCount}个）");
        sb.Append($"\n仅显示容器本身价格");
        sb.Append($"\n跳蚤市场: {TextFormatting.FormatPrice(containerPrice.Value)}");
        return sb.ToString();
    }

    // 小容器：完整计算
    double itemsPrice = CalculateContainerItemsPrice(container, 0);
    // ...
}

private static int EstimateContainerItemCount(Item container)
{
    // 快速估算：不递归，只统计第一层物品数量
    int count = 0;
    var gridsProperty = container.GetType().GetProperty("Grids");
    if (gridsProperty == null) return 0;

    var grids = gridsProperty.GetValue(container) as IEnumerable;
    if (grids == null) return 0;

    foreach (var grid in grids)
    {
        var itemsProperty = grid.GetType().GetProperty("Items");
        if (itemsProperty != null)
        {
            var items = itemsProperty.GetValue(grid) as IEnumerable;
            if (items != null)
                count += items.Cast<object>().Count();
        }
    }

    return count;
}
```

#### 效果
- **小容器**（<50物品）：正常计算
- **大容器**（>100物品）：跳过计算，显示警告
- **性能**：永远不会卡顿（最坏情况 <50ms）

---

## 📋 推荐实施顺序

### 阶段 1（立即实施）：基础优化
1. ✅ **降低递归深度**：50层 → 5层（99%的情况下够用）
2. ✅ **添加物品数量限制**：默认最多计算 50 个物品
3. ✅ **智能跳过大容器**：>100 个物品直接跳过

**预期效果**：卡顿问题 90% 解决

### 阶段 2（后续优化）：缓存机制
4. ⭐ **添加结果缓存**：5秒有效期
5. ⭐ **定期清理缓存**：避免内存泄漏

**预期效果**：重复查询几乎无延迟

### 阶段 3（高级优化）：异步计算
6. 🔧 **异步计算 + 渐进式显示**（可选，复杂度高）

**预期效果**：完全无卡顿感

---

## 🎯 配置项建议

```csharp
// Settings.cs 新增配置
public static ConfigEntry<int> MaxContainerItems;        // 最大计算物品数 (默认 50)
public static ConfigEntry<int> MaxContainerDepth;        // 最大递归深度 (默认 5)
public static ConfigEntry<bool> SimplifyContainer;       // 简化容器计算 (默认 false)
public static ConfigEntry<bool> SkipLargeContainers;     // 跳过大容器 (默认 true)
public static ConfigEntry<int> LargeContainerThreshold;  // 大容器阈值 (默认 100)
```

---

## 💡 性能对比（估算）

| 场景 | 当前实现 | 方案1+2 | 方案1+2+4 |
|------|---------|---------|-----------|
| 空背包 | 10ms | 5ms | 5ms |
| 50物品背包 | 150ms | 50ms | 50ms |
| 100物品背包 | 500ms | 100ms | **跳过** |
| 300物品箱子 | 2000ms+ | 400ms | **跳过** |
| 嵌套容器（5层） | 1000ms+ | 200ms | 100ms |

**关键指标**：
- ✅ 目标延迟：<100ms（用户无感知）
- ✅ 优化后：95% 的情况 <50ms

---

## ⚙️ 需要您决定

请告诉我您想实施哪个方案：

1. **快速修复**（推荐）：方案 1 + 方案 4（限制物品数 + 智能跳过）
   - 实施难度：★☆☆☆☆
   - 效果：★★★★☆
   - 实施时间：10-15 分钟

2. **完整优化**（最佳）：方案 1 + 方案 2 + 方案 4（限制 + 缓存 + 跳过）
   - 实施难度：★★☆☆☆
   - 效果：★★★★★
   - 实施时间：20-30 分钟

3. **仅提供分析**：不修改代码，仅提供此文档供参考

请告诉我您的选择！
